## Computational Thinking in Parallel Programming

### Introdução
Este capítulo dedica-se ao **pensamento computacional** (*computational thinking*), um aspecto fundamental no desenvolvimento de aplicações paralelas [^21]. Como mencionado anteriormente [^21], o pensamento computacional é melhor compreendido através de uma abordagem iterativa, oscilando entre experiência prática e conceitos abstratos. Os kernels de mapa de potencial eletrostático utilizados no Capítulo 12 e neste capítulo servem como exemplos eficazes de pensamento computacional [^21].

### Conceitos Fundamentais

**Definição de Pensamento Computacional:** O *computational thinking* é definido como o processo de formular problemas de domínio em termos de etapas computacionais e algoritmos [^21]. É essencial para o desenvolvimento de aplicações paralelas eficientes e requer uma abordagem iterativa entre experiência prática e conceitos abstratos [^1]. Em essência, envolve analisar e transformar a estrutura de um problema, identificando partes inerentemente seriais e aquelas adequadas para execução paralela de alto desempenho [^1].

**Habilidades Fundamentais:** Um programador paralelo eficaz necessita de diversas habilidades para ser um *computational thinker* proficiente [^21]:

1.  **Arquitetura de Computadores:** Compreensão da organização da memória, *caching* e localidade, largura de banda da memória, execução SIMT versus SPMD versus SIMD e precisão de ponto flutuante versus exatidão. Estes conceitos são cruciais para entender as *trade-offs* entre algoritmos [^21].
2.  **Modelos de Programação e Compiladores:** Conhecimento de modelos de execução paralela, tipos de memórias disponíveis, *layout* de dados de *arrays* e transformação da granularidade de *threads*. Estes conceitos são necessários para analisar as estruturas de dados e estruturas de *loop* para alcançar melhor desempenho [^21].
3.  **Técnicas de Algoritmos:** Familiaridade com *tiling*, *cutoff*, *scatter-gather*, *binning* e outras técnicas. Estas técnicas formam o conjunto de ferramentas para projetar algoritmos paralelos superiores. A compreensão da escalabilidade, eficiência e implicações da largura de banda da memória destas técnicas é essencial no pensamento computacional [^21].
4.  **Conhecimento do Domínio:** Familiaridade com métodos numéricos, precisão, exatidão e estabilidade numérica. A compreensão destas regras básicas permite que um desenvolvedor seja muito mais criativo na aplicação de técnicas de algoritmos [^21].

**O Processo de Pensamento Computacional:**

1.  **Decomposição do Problema:** Para desenvolver uma aplicação paralela eficiente, é fundamental começar com uma boa decomposição de alto nível do problema [^21]. Por exemplo, no problema do mapa de potencial eletrostático, discutido na Seção 13.2 [^21], é crucial ter uma compreensão clara dos comportamentos de acesso à memória desejáveis (por exemplo, *gather* em CUDA) e indesejáveis (por exemplo, *scatter* em CUDA) para tomar decisões acertadas [^21].
2.  **Seleção de Algoritmos:** Dada uma decomposição do problema, programadores paralelos enfrentam a tarefa potencialmente complexa de projetar algoritmos para superar os principais desafios em paralelismo, eficiência de execução e consumo de largura de banda da memória [^21]. É importante notar que existe um grande volume de literatura sobre uma ampla gama de técnicas de algoritmos que podem ser difíceis de entender [^21].
3. **Trade-offs:** Dado um decisão de decomposição do problema, os programadores normalmente terão que selecionar entre uma variedade de algoritmos [^22]. Alguns desses algoritmos conseguem diferentes *trade-offs* enquanto mantêm a mesma precisão numérica [^22]. Outros envolvem sacrificar algum nível de precisão para alcançar tempos de execução muito mais escaláveis [^22].

**Exemplo Prático: Mapa de Potencial Eletrostático**

Os *kernels* de mapa de potencial eletrostático utilizados no Capítulo 12 e neste capítulo servem como excelentes exemplos de *computational thinking* [^21]. Para desenvolver uma aplicação paralela eficiente que resolva o problema do mapa de potencial eletrostático, é preciso elaborar uma boa decomposição de alto nível do problema [^21].

### Conclusão

O *computational thinking* é uma habilidade essencial para o desenvolvimento de aplicações paralelas eficientes [^21]. Envolve a formulação de problemas em termos computacionais, a seleção de algoritmos adequados e a compreensão das *trade-offs* entre diferentes abordagens [^21]. Embora este livro forneça uma base sólida, é fundamental que os leitores continuem a expandir seu conhecimento e a praticar a resolução de problemas desafiadores para aprimorar suas habilidades de *computational thinking* [^21]. A estratégia de *cutoff* é talvez a mais popular de tais estratégias [^22]. Mesmo que tenhamos introduzido o *cutoff* no contexto do cálculo do mapa de potencial eletrostático, ele é usado em muitos domínios, incluindo o traçado de raios em gráficos e a detecção de colisão em jogos [^22]. As habilidades de pensamento computacional permitem que um *designer* de algoritmos trabalhe em torno dos bloqueios e alcance uma boa solução [^22].

### Referências
[^1]: Página 281: "Computational thinking is defined as the process of formulating domain problems in terms of computational steps and algorithms. It is essential for developing efficient parallel applications and requires an iterative approach between practical experience and abstract concepts."
[^21]: Página 293: "Computational thinking is arguably the most important aspect of parallel application development [Wing2006]. We define computational thinking as the thought process of formulating domain problems in terms of computation steps and algorithms. Like any other thought processes and problem-solving skills, computational thinking is an art. As we mentioned in Chapter 1, we believe that computational thinking is best taught with an iterative approach where students bounce back and forth between practical experience and abstract concepts. The electrostatic potential map kernels used in Chapter 12 and this chapter serve as good examples of computational thinking. To develop an efficient parallel application that solves the electrostatic potential map problem, one must come up with a good high-level decomposition of the problem. As we showed in Section 13.2, one must have a clear understanding of the desirable (e.g., gather in CUDA) and undesirable (e.g., scatter in CUDA) memory access behaviors to make a wise decision. Given a problem decomposition, parallel programmers face a potentially overwhelming task of designing algorithms to overcome major challenges in parallelism, execution efficiency, and memory bandwidth consumption. There is a very large volume of literature on a wide range of algorithm techniques that can be hard to understand. It is beyond the scope of this book to have a comprehensive coverage of the available techniques. We did discuss a substantial set of techniques that have broad applicability. While these techniques are based on CUDA, they help readers build up the foundation for computational thinking in general. We believe that humans understand best when we learn from the bottom up. That is, we first learn the concepts in the context of a particular programming model, which provides us with solid footing before we generalize our knowledge to other programming models. An in-depth experience with the CUDA model also enables us to gain maturity, which will help us learn concepts that may not even be pertinent to the CUDA model. There is a myriad of skills needed for a parallel programmer to be an effective computational thinker. We summarize these foundational skills as follows: • Computer architecture: memory organization, caching and locality, memory bandwidth, SIMT versus SPMD versus SIMD execution, and floating-point precision versus accuracy. These concepts are critical in understanding the trade-offs between algorithms."
[^22]: Página 294: "In summary, we have discussed the main dimensions of algorithm selection and computational thinking. The key lesson is that given a problem decomposition decision, programmers will typically have to select from a variety of algorithms. Some of these algorithms achieve different trade-offs while maintaining the same numerical accuracy. Others involve sacrificing some level of accuracy to achieve much more scalable running times. The cutoff strategy is perhaps the most popular of such strategies. Even though we introduced cutoff in the context of electrostatic potential map calculation, it is used in many domains including ray tracing in graphics and collision detection in games. Computational thinking skills allow an algorithm designer to work around the roadblocks and reach a good solution."
<!-- END -->